i

array 1: 0, 1, 2
array 2: 3, 4, 5
array 3: 6, 7, 8
  
  0, 3, 6
  
  array 1 ... n
  
  vector<pair<string, string>> kv
  sortNarrays(vector<vector<pair<string, string>>> &N)
{
    auto col = N.size();
    auto row = N[0].size();
    priority_queue<pair<string, string>, vector<pair<string, string>, greater<pair<string, string>> pq;
    for (auto i = 0; i < row; i++) {
        for (auto j = 0; j < col; j++) {
            pq.emplace(N[j][i].first, N[j][i].second);
        }
        pair<string, string> temp = pq.front();
        pq.pop();
    }
    
}

anirvan@cohesity.com





## How is fragmentation tackled in your Velocity?
## Periodic and background process, runs when the system is idle.
## Single node system


/*
1. Define a node in a linked list with two pointers next pointer and random pointer.
2. Clone a linked list with next and random pointer

For example:
A ---> B ---> C ---> D ---> E

A -r-> C
B -r-> E
C -r-> D
D -r-> A
E -r-> B
*/

// A ---> B ---> C --->null

// A -> A1 -> B -> B1 -> C -> C1 -> nul


struct Node {
    int val;
    Node *next, *random;
    Node (int x) : val(x), nexgt(nullptr), random(nullptr) { }
};


Node  *clone (Node *root)
{
    if (nullptr == root) return root;
  
    Node *cur = root;
    // Step1: Creating nodes in between
    while (cur) {
        Node *p = cur->next;
        cur->next = new Node(cur->val);
        cur->next->next = p;
        cur = p;
    }
  
    cur = root;
  // Step-2: copying the random pointers;
    while (cur) {
        cur->next->random = cur->random ? cur->random->next:nullptr;
      cur = cur->next->next;
    }
  
  // seperate the lists
  // A -> A1 -> B -> B1 -> C -> C1 -> null
  Node *pr = root, *clone = root->next;
  Node *tmp = clone;
  while (clone) {
     pr->next =  pr->next->next;
     pr = pr->next;
     clone->next = clone->next ? clone->next->next : clone->next;
     clone = clone->next;
  }
  return tmp;
}
